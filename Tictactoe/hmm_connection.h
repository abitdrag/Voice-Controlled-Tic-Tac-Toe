#include <stdio.h>
#include <stdlib.h>
#include <cstdio>
#include <Windows.h>
#include <string.h>
#include <ctype.h>
#include <math.h>
#include <float.h>

// imports from HMM model
/*
#include "stdafx.h"
#include "utils.h"
#include "constants.h"
#include "paths.h"
#include "forward_backward_procedure.h"
#include "viterbi_algorithm.h"
#include "baum_welch.h"
#include "codebook_manager.h"
#include "observation_sequence_manager.h"
#include "globals.h"
*/


// defining constants
#define N 5
#define M 32
#define T 85	// number of frames that are taken - always odd
#define word_count 10
#define TRAINING_SEQUENCES 20
#define TESTING_SEQUENCES 10
#define ITERATIONS 100
#define TOTAL_FRAMES 150
#define p 12
#define SAMPLES_PER_FRAME 320
#define frame 5

// defining all functions
void calculate_xai(bool is_xai_prined, int x, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1], long double beta[T+1][N+1], long double xai[T+1][N+1][N+1]);
void calculate_gamma(bool is_gamma_printed, int x, long double alpha[T+1][N+1], long double beta[T+1][N+1], long double gamma[T+1][N+1]);
void print_gamma(long double gamma[T+1][N+1]);
void find_pibar(bool is_pi_bar_printed, int x, long double gamma[T+1][N+1], long double Pi_BAR[N+1]);
void find_abar(bool is_abar_printed, int x, long double A_BAR[N+1][N+1], long double xai[T+1][N+1][N+1], long double gamma[T+1][N+1]);
void print_a_bar(long double A_BAR[N+1][N+1]);
void find_bbar(bool is_bbar_prined, int x, long double B_BAR[N+1][M+1], long double xai[T+1][N+1][N+1], long double gamma[T+1][N+1], long int Observarion_sequence[TRAINING_SEQUENCES+1][T+1]);
void read_codebook(bool is_codebook_printed, char *filename, long double codebook[M+1][p+1]);
long double generate_alpha(bool is_print_alpha, bool is_print_prob_result, int x, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1]);
void print_probability(long double alpha[T+1][N+1]);
void generate_beta(bool is_print_beta, int x, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[T+1], long double beta[T+1][N+1]);
void print_beta(long double beta[T+1][N+1]);
void print_alpha(long double alpha[T+1][N+1]);
void generate_paths();
void clean_arrays(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1], long double beta[T+1][N+1],
					long double delta[N+1][T+1], long double psi[N+1][T+1], int Q_star[T+1], long double *p_star);
void viterbi_algorithm(bool is_print_result, int seq, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double delta[N+1][T+1], long double psi[N+1][T+1], int Q_star[T+1], long double *p_star);

// global variables
// Paths of all input and output files
char A_file_paths_train[word_count][100];
char A_file_paths_test[word_count][100];
char B_file_paths_train[word_count][100];
char B_file_paths_test[word_count][100];
char Pi_file_paths_train[word_count][100];
char Pi_file_paths_test[word_count][100];
char Observation_sequence_file_paths_train[word_count][100];
char Observation_sequence_file_paths_test[word_count][100];
char sample_files_train[word_count][TRAINING_SEQUENCES+1][100];
char sample_files_test[word_count][TESTING_SEQUENCES+1][100];
char codebook_file_path[100];

// varaibles generated by model
long double A[N+1][N+1];
long double B[N+1][M+1];
long double Pi[N+1];
long int Observation_sequence[TRAINING_SEQUENCES+1][T+1];
long double alpha[T+1][N+1];
long double beta[T+1][N+1];
long double delta[N+1][T+1];
long double psi[N+1][T+1];
long double P_star, old_pstar;
int Q_star[T+1];
long double xai[T+1][N+1][N+1];
long double gamma[T+1][N+1];
long double A_BAR[N+1][N+1];
long double B_BAR[N+1][M+1];
long double Pi_BAR[N+1];
long double collect_A[TRAINING_SEQUENCES+1][N+1][N+1];
long double collect_B[TRAINING_SEQUENCES+1][N+1][M+1];
long double codebook[M+1][p+1];
long double weight[p];

// global array
char words[][20]={"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};


void record(){
	char command[200];
	sprintf(command, "Recording_Module.exe 3 samples.wav samples.txt");
	system(command);
}

void reestimation(long double A[N+1][N+1],
					long double B[N+1][M+1],
					long double Pi[N+1],
					long int Observation_sequence[TRAINING_SEQUENCES+1][T+1],
					long double alpha[T+1][N+1],
					long double beta[T+1][N+1],
					long double delta[N+1][T+1],
					long double psi[N+1][T+1],
					long double *P_star,
					int Q_star[T+1],
					long double xai[T+1][N+1][N+1],
					long double gamma[T+1][N+1],
					long double A_BAR[N+1][N+1],
					long double B_BAR[N+1][M+1],
					long double Pi_BAR[N+1], int x){
						calculate_xai(false, x, A, B, Pi, Observation_sequence, alpha, beta, xai);
						find_pibar(false, x, gamma, Pi);
						find_abar(false, x, A_BAR, xai, gamma);
						find_bbar(false, x, B_BAR, xai, gamma, Observation_sequence);
}

void calculate_xai(bool is_xai_prined, int seq, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1], long double beta[T+1][N+1], long double xai[T+1][N+1][N+1]){
	for(int t=1; t<T; t++){
		long double probability_of_given_lambda = 0;
		for(int i=1; i<N+1; i++){
			for(int j=1; j<N+1; j++){
				probability_of_given_lambda += (alpha[t][i] * A[i][j] * B[j][Observation_sequence[seq][t+1]] * beta[t+1][j]);
				// printf("\nprob: %g", probability_of_of_given_lambda);
			}
		}
		for(int i=1; i<N+1; i++){
			for(int j=1; j<N+1 ;j++){
				xai[t][i][j] = (alpha[t][i] * A[i][j] * B[j][Observation_sequence[seq][t+1]] * beta[t+1][j]) / probability_of_given_lambda;
				if(t==1 && is_xai_prined){
					printf("%g ", xai[t][i][j]);
				}
			}
			if(t==1 && is_xai_prined){
				printf("\n");
			}
		}
	}
}

// calculate the values of gamma
void calculate_gamma(bool is_gamma_printed, int seq, long double alpha[T+1][N+1], long double beta[T+1][N+1], long double gamma[T+1][N+1]){
	for(int t=1; t<T+1; t++){
		long double sum = 0;
		for(int i=1; i<N+1; i++){
			sum += (alpha[t][i] * beta[t][i]);
		}
		for(int i=1; i<N+1; i++){
			gamma[t][i] = (alpha[t][i] * beta[t][i]) / sum;
		}
	}

	if(is_gamma_printed){
		print_gamma(gamma);
	}
}

// This function prints the gamma value
void print_gamma(long double gamma[T+1][N+1]){
	printf("\nPrinting gamma:\n");
	for(int t=1; t<T+1; t++){
		for(int i=1; i<N+1; i++){
			printf("%g ",gamma[t][i]);
		}
		printf("\n");
	}
}

// This function finds the new values for pi
void find_pibar(bool is_pi_bar_printed, int x, long double gamma[T+1][N+1], long double Pi_BAR[N+1]){
	if(is_pi_bar_printed)
		printf("\nNew PI:\n");
	for(int i=1; i<N+1; i++){
		Pi_BAR[i] = (int)gamma[1][i];
		if(is_pi_bar_printed)
			printf("%g ", Pi_BAR[i]);
	}
	if(is_pi_bar_printed)
		printf("\n");
}

// This function finds the A bar
void find_abar(bool is_abar_printed, int x, long double A_BAR[N+1][N+1], long double xai[T+1][N+1][N+1], long double gamma[T+1][N+1]){
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			long double num = 0, den = 0;
			for(int t=1; t<=T-1; t++){
				num += xai[t][i][j];
				den += gamma[t][i];
			}
			A_BAR[i][j] = num/den;
		}
	}
	if(is_abar_printed){
		print_a_bar(A_BAR);
	}
}

// This function prints the A bar
void print_a_bar(long double A_BAR[N+1][N+1]){
	printf("\nA bar:\n");
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			printf("%g ", A_BAR[i][j]);
		}
		printf("\n");
	}
}

// This function finds the value of B bar
void find_bbar(bool is_bbar_prined, int seq, long double B_BAR[N+1][M+1], long double xai[T+1][N+1][N+1], long double gamma[T+1][N+1], long int Observarion_sequence[TRAINING_SEQUENCES+1][T+1]){
	if(is_bbar_prined)
			printf("\nB bar:\n");
	for(int j=1; j<N+1; j++){
		for(int k=1; k<M+1; k++){
			long double num = 0, den = 0;
			for(int t=1; t<T+1; t++){
				if(Observarion_sequence[seq][t] == k)
					num += gamma[t][j];
				den += gamma[t][j];
			}
			B_BAR[j][k] = num/den;
		}
	}

	/*
	// refine B_BAR
	for(int j=1;j<=N;j++){
		long double row_sum = 0;
		int max_index = 0;
		for(int k=1;k<=M;k++){
			if(B_BAR[j][k] == 0)
				B_BAR[j][k] = 1e-030;
			if(B_BAR[j][k] > B_BAR[j][max_index])
				max_index = k;
			row_sum += B_BAR[j][k];
		}
		B_BAR[j][max_index] -= (row_sum-1); 
	}

	for(int j=1;j<=N;j++){
		for(int k=1;k<=M;k++){
			if(is_bbar_prined)
				printf("%g ",B_BAR[j][k]);
		}
		if(is_bbar_prined)
			printf("\n");
	}
	*/
}

void read_codebook(bool is_codebook_printed, char *filename, long double codebook[M+1][p+1]){
	FILE *codebook_file = fopen(filename, "r");
	if(!codebook_file){
		printf("Cannot open the file!\n");
		return;
	}
 
	for (int i = 1; i <= M; ++i)
		for (int j = 1; j <= p; ++j)
			fscanf(codebook_file,"%lf", &codebook[i][j]);
	fclose(codebook_file);
	
	if(is_codebook_printed){
		printf("\n-----------CODEBOOK-----------\n");
		for(int i=1; i<M+1; ++i){
			for(int j=1; j<p+1; ++j){
				printf("%g ", codebook[i][j]);
			}
			printf("\n");
		}
	}
}

// This function uses forward procedure to generate the matrix alpha
// INPUTS: If is_print_alpha is true then this funcion prints alpha matrix
//		   If is_print_probabiliy_result is true then this function prints the probability calculated using alpha
// OUTPUTS: Sets the values of alpha and returns the forward probability
long double generate_alpha(bool is_print_alpha, bool is_print_prob_result, int seq, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1]){
	// print_A(A);
	// print_B(B);
	// print_Pi(Pi);
	// Initialization using Pi - initial probability
	for(int i=1; i<N+1; i++){
		alpha[1][i] = Pi[i] * B[i][Observation_sequence[seq][1]];
	}

	// Recursively finding ALPHA
	long double temp_sum = 0;
	for(int t=2; t<T+1; t++){
		for(int j=1; j<N+1; j++){
			temp_sum  = 0.0;
			for(int i=1; i<N+1; i++){
				temp_sum += (alpha[t-1][i] * A[i][j]);
			}
			alpha[t][j] = temp_sum * B[j][Observation_sequence[seq][t]];
		}
	}

	// check if alpha needs to be printed or not
	if(is_print_alpha){
		print_alpha(alpha);
	}

	// check if resulting probability using alpha needs to be printed
	if(is_print_prob_result){
		print_probability(alpha);
	}

	// return result
	// calculating probability
	long double prob=0;
	for(int i=1; i<N+1; i++){
		prob += alpha[T][i];
	}
	return prob;
}


// This function calculates and prints the probability of an observation sequence for given model using forward procedure
void print_probability(long double alpha[T+1][N+1]){
	// calculating probability
	long double temp_sum=0;
	for(int i=1; i<N+1; i++){
		temp_sum += alpha[T][i];
	}
	printf("\nP(O|lambda) = %Le\n", temp_sum);
}

// This function prints the alpha matrix
// This function prints beta matrix
void print_alpha(long double alpha[T+1][N+1]){
	printf("\nAlpha matrix:\n");
	for(int i=1;i<T+1;i++){
		for(int j=1;j<N+1;j++){
			printf("%Le\t", alpha[i][j]);
		}
		printf("\n");
	}
}

// This function uses backward procedure to calculate beta
// INPUT: if is_print_beta is true then this function will print beta matrix too
void generate_beta(bool is_print_beta, int seq, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double beta[T+1][N+1]){
	// Initialization
	for(int i=1; i<N+1; i++){
		beta[T][i] = 1;
	}

	// Recrusviely calculating beta
	for(int t=T-1; t>=1; t--){
		for(int i=1; i<N+1; i++){
			long double temp_sum = 0;
			for(int j=1; j<N+1; j++){
				temp_sum += (A[i][j] * B[j][Observation_sequence[seq][t+1]] * beta[t+1][j]);
			}
			beta[t][i] = temp_sum;
		}
	}

	// check if result needs to be printed
	if(is_print_beta){
		print_beta(beta);
	}
}

// This function prints beta matrix
void print_beta(long double beta[T+1][N+1]){
	printf("\nBeta matrix:\n");
	for(int i=1;i<T+1;i++){
		for(int j=1;j<N+1;j++){
			printf("%g\t", beta[i][j]);
		}
		printf("\n");
	}
}

// This function will normalize the input from first file and write it to the second file
// The limit of normalization chosen here is 5000
void normalize_input(FILE *input, FILE *output, int limit = 5000){
	double max = 0, dcShift = 0, sampleCount = 0;
	char singleLine[100];

	//calculate DC shift
	while(!feof(input)){
		fgets(singleLine, 100, input);
		if(!isalpha(singleLine[0])){
			double x = atof(singleLine);
			dcShift += x;
			sampleCount ++;
		}
	}
	sampleCount--;
	dcShift /= (sampleCount);
	//calculate normalization factor
	rewind(input);
	while(!feof(input)){
		fgets(singleLine, 100, input);
		if(!isalpha(singleLine[0])){
			double x = atof(singleLine);
			if(max < abs(x)){
				max = abs(x);
			}
		}
	}
	double normalizationFactor = abs(max - limit)/(max * 1.0);
	rewind(input);
	while(!feof(input)){
		fgets(singleLine, 100, input);
		if(!isalpha(singleLine[0])){
			double x = atof(singleLine);
			double normalized_output = (x-dcShift) * normalizationFactor;
			/*if(normalized_output > 100){
				printf("%lf\n", normalized_output);
			}*/
			fprintf(output, "%g\n", normalized_output);
		}
	}
}

// This function skips the frames
long skipFrames(FILE *input, long skipFrameCnt = 25*N){
	long cnt = 0, pos;
	char singleLine[100];
	while(!feof(input)){
		fgets(singleLine, 100, input);
		if(!isalpha(singleLine[0]))
			cnt ++;
		if(cnt > skipFrameCnt){
			pos = ftell(input);
			break;
		}
	}
	return pos;
}


//This function finds the steady frames and stores them in s
void skip_frames(FILE *input, long double stable_frames[TOTAL_FRAMES+1][SAMPLES_PER_FRAME+1]){
	char singleLine[100];
	long double samples[TOTAL_FRAMES+1][SAMPLES_PER_FRAME+1] = {{0}}, energy[TOTAL_FRAMES+1] = {0};
	int sampleCnt = 0, frameCnt = 0, pos = 0;
	
	//reading the entire input and dividing them into frames and saving it in a
	//matrix (samples) of size number of frames x 320 (N)
	rewind(input);
	while(!feof(input) && frameCnt<TOTAL_FRAMES){
		fgets(singleLine, 100, input);
		if(!isalpha(singleLine[0])){
			samples[frameCnt][sampleCnt] = atof(singleLine);
			if(sampleCnt >= SAMPLES_PER_FRAME){
				sampleCnt = 0;
				frameCnt ++;
			}
			else{
				sampleCnt++;
			}
			// if(samples[frameCnt][sampleCnt] > 1000)
				// printf("%lf ", samples[frameCnt][sampleCnt]);
		}
	} 

	//calculating STE for each of the frames and saving it in an array
	for(int i=0; i<TOTAL_FRAMES; i++){
		long double sum = 0;
		for(int j=0; j<SAMPLES_PER_FRAME; j++){
			sum += (samples[i][j] * samples[i][j]);
		}
		energy[i] = sum/((long double)SAMPLES_PER_FRAME);
		// printf("%lf\n", energy[i]);
	}

	//finding out the frame with max STE and saving it in pos
	long double maxEnergy = DBL_MIN;
	for(int i=0; i<TOTAL_FRAMES; i++){
		if(energy[i] > maxEnergy){
			maxEnergy = energy[i];
			pos = i;
		}
	}

	for(int i=0; i<TOTAL_FRAMES; ++i){
		for(int j=0; j<SAMPLES_PER_FRAME; ++j){
			stable_frames[i][j] = samples[i][j];
		}
		i++;
	}
}

// This function applies hamming window on the sample data
double hammingWindow(int m){
	return (0.54-0.46*cos(2*3.14*m/N-1));
}


// This function applies hamming window on all stable frames passed as parameter
void applyHamming(long double s[TOTAL_FRAMES+1][SAMPLES_PER_FRAME+1]){
	for(int i=0; i<TOTAL_FRAMES; ++i){
		for(int j=0; j<SAMPLES_PER_FRAME; ++j){
			s[i][j] *= hammingWindow(s[i][j]);
		}
	}

}

// This function calculates R and stores it in r array
void calculateR(long double s[TOTAL_FRAMES+1][SAMPLES_PER_FRAME+1], long double r[TOTAL_FRAMES+1][p+1]){
	for(int f=0; f<TOTAL_FRAMES; ++f){
		for(int k=0; k<=p; ++k){
			for(int m=0; m<=SAMPLES_PER_FRAME-k-1; ++m){
				r[f][k] += s[f][m]*s[f][m+k];
			}
		}
	}
}

// This function calculates A and stores it in array a
void calculateA(long double r[TOTAL_FRAMES+1][p+1], long double a[TOTAL_FRAMES+1][p+1]){
	for(int f=0; f<TOTAL_FRAMES; ++f){
		double e[p+1] = {0}, k[p+1] = {0},  alpha[p+1][p+1] = {{0}};
		e[0] = r[f][0];
		for(int i=1; i<=p; ++i){
			double sum = 0;
			for(int j=1; j<=i-1; ++j){
				sum += alpha[i-1][j]*r[f][i-j];
			}
			k[i] = (r[f][i] - sum)/e[i-1];
			alpha[i][i] = k[i];
			for(int j=1; j<=i-1; ++j){
				alpha[i][j] = alpha[i-1][j] - k[i] * alpha[i-1][i-j];
			}
			e[i] = (1-k[i]*k[i])*e[i-1];
		}
		for(int i=1; i<=p; ++i){
			a[f][i] = alpha[p][i];
		}
	}
}

// This function applys the raised sin window on Ci's
double raisedSin(int m){
	return 1+(p*1.0/2)*sin(3.14*m/12);
}

// This function generates the C matrix
void calculateC(long double r[TOTAL_FRAMES+1][p+1], long double a[TOTAL_FRAMES+1][p+1], long double c[TOTAL_FRAMES+1][p+1]){
	for(int f=0; f<TOTAL_FRAMES; ++f){
		double sigma = r[f][0];
		c[f][0] = log10(sigma*sigma);
		for(int m=1; m<=p; ++m){
			double sum = 0;
			for(int k=1; k<=m-1; ++k){
				sum += (k/(m*1.0))*c[f][k]*a[f][m-k];
			}
			c[f][m] = a[f][m] + sum;
		}
	}

	//applying raised sin
	for(int i=0; i<TOTAL_FRAMES; ++i){
		for(int j=1; j<=p; ++j){
			c[i][j] *= raisedSin(j);
		}
	}
}

// This function calculates the tokhura distance between two ci's 
long double tokhura_distance(long double ci[p+1], long double codebook[p+1], long double weight[p]){
	long double distance = 0;
	for(int i=1; i<p+1; i++){
		long double prod = weight[i-1]*(ci[i]-codebook[i])*(ci[i]-codebook[i]);
		distance = distance + prod;
	}
	return distance;
}

// This function generates an observation sequence for a digit for given sequence number
// The result is stored in the array Observation_sequence
void generate_observation_sequence(long double codebook[M+1][p+1], char *samples_filename, int seq, long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double weight[p]){
	// get file pointers
	FILE *input = fopen(samples_filename, "r");
	if(!input){
		printf("Cannot open file %s!", samples_filename);
		return;
	}
	FILE *input_normalized = fopen("normalized_input.txt", "w+");
	if(!input_normalized){
		printf("Cannot open file normalized_input.txt!");
		return;
	}
	// Initialize other variables
	long double stable_frames[TOTAL_FRAMES+1][SAMPLES_PER_FRAME+1], r[TOTAL_FRAMES+1][p+1] = {{0}}, a[TOTAL_FRAMES+1][p+1] = {{0}}, c[TOTAL_FRAMES+1][p+1] = {{0}};
	// write the normalized input in normalized_input.txt file
	normalize_input(input, input_normalized);

	// skip the frames and find the stable frames
	skip_frames(input_normalized, stable_frames);
	// applying hamming window on stable frames
	applyHamming(stable_frames);
	// calculating R matrix
	calculateR(stable_frames, r);
	// calculating A matrix
	calculateA(r, a);
	// calculating C matrix
	calculateC(r, a, c);
	// This function will calculate the tokhura distance
	for(int i=1; i<=T; ++i){
		long double min_distance = DBL_MAX;
		int min_index = -1;
		for(int j=1; j<=M; ++j){
			long double distance = tokhura_distance(c[i], codebook[j], weight);
			//printf("Distance: %g Frame:%d Sequence:%d\n", distance, i, seq);
			if(min_distance > distance){
				min_distance = distance;
				min_index = j;
			}
		}
		// update the observation sequence 
		Observation_sequence[seq][i] = min_index;
	}
	fclose(input);
	fclose(input_normalized);
}

// This function writes the observation sequences for a word to the file
void write_observation_sequence_to_file(long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], char *filename){
	FILE *observation_sequence_file = fopen(filename, "w");
	if(!observation_sequence_file){
		printf("Cannot open file %s!", filename);
		return;
	}
	for(int i=1; i<TRAINING_SEQUENCES+1; i++){
		for(int j=1; j<T+1; j++){
			fprintf(observation_sequence_file, "%d ", Observation_sequence[i][j]);
		}
		fprintf(observation_sequence_file, "\n");
	}
	fclose(observation_sequence_file);
}

// This function writes the observation sequences of test files for a word to the file
void write_observation_sequence_to_file_test(long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], char *filename){
	FILE *observation_sequence_file = fopen(filename, "w");
	if(!observation_sequence_file){
		printf("Cannot open file %s!", filename);
		return;
	}
	for(int i=1; i<TESTING_SEQUENCES+1; i++){
		for(int j=1; j<T+1; j++){
			fprintf(observation_sequence_file, "%d ", Observation_sequence[i][j]);
		}
		fprintf(observation_sequence_file, "\n");
	}
	fclose(observation_sequence_file);
}

// This function generates the dynamic file paths for all files of digits 0 to 9
void generate_paths(){

	// generate dynamic paths
	for(int i=0; i<word_count; i++){

		// initialize the initial fine name
		char A_filename_train[60] = "Allfiles/train/lambda/A_";
		char B_filename_train[60] = "Allfiles/train/lambda/B_";
		char Pi_filename_train[60] = "Allfiles/train/lambda/Pi_";
		char OS_filename_train[60] = "Allfiles/train/Observations/OBS_SEQ_";
		char A_filename_test[60] = "Allfiles/test/lambda/A_";
		char B_filename_test[60] = "Allfiles/test/lambda/B_";
		char Pi_filename_test[60] = "Allfiles/test/lambda/Pi_";
		char OS_filename_test[60] = "Allfiles/test/Observations/OBS_SEQ_";
		char fileend[30] = ".txt";
		char middle[10] = "/";

		// generating path for A files
		// train files
		strcat(A_filename_train, words[i]);
		strcat(A_filename_train, fileend);
		strcat(A_file_paths_train[i], A_filename_train);
		// test files
		strcat(A_filename_test, words[i]);
		strcat(A_filename_test, fileend);
		strcat(A_file_paths_test[i], A_filename_test);
		
		// generating path for B files
		strcat(B_filename_train, words[i]);
		strcat(B_filename_train, fileend);
		strcat(B_file_paths_train[i], B_filename_train);
		strcat(B_filename_test, words[i]);
		strcat(B_filename_test, fileend);
		strcat(B_file_paths_test[i], B_filename_test);
		// printf("%s\n", B_file_paths[i]);

		// generating path for Pi files
		strcat(Pi_filename_train, words[i]);
		strcat(Pi_filename_train, fileend);
		strcat(Pi_file_paths_train[i], Pi_filename_train);
		strcat(Pi_filename_test, words[i]);
		strcat(Pi_filename_test, fileend);
		strcat(Pi_file_paths_test[i], Pi_filename_test);
		// printf("%s\n", Pi_file_paths[i]);

		// generating path for Observation sequence files
		strcat(OS_filename_train, words[i]);
		strcat(OS_filename_train, fileend);
		strcat(Observation_sequence_file_paths_train[i], OS_filename_train);
		strcat(OS_filename_test, words[i]);
		strcat(OS_filename_test, fileend);
		strcat(Observation_sequence_file_paths_test[i], OS_filename_test);
		// printf("%s\n", Observation_sequence_file_paths[i]);

		// generating the path for the training files
		for(int j=1; j<TRAINING_SEQUENCES+1; j++){
			char sample_train_filename[50] = "Allfiles/train/";
			char str[10];
			strcat(sample_train_filename, words[i]);
			strcat(sample_train_filename, middle);
			strcat(sample_train_filename, "obs_");
			strcat(sample_train_filename, itoa(j, str, 10));
			strcat(sample_train_filename, fileend);
			strcat(sample_files_train[i][j], sample_train_filename);
		}

		// generating the path for the testing files
		for(int j=1; j<TESTING_SEQUENCES+1; j++){
			char sample_test_filename[50] = "Allfiles/test/";
			char str[10];
			strcat(sample_test_filename, words[i]);
			strcat(sample_test_filename, middle);
			strcat(sample_test_filename, "obs_");
			strcat(sample_test_filename, itoa(j, str, 10));
			strcat(sample_test_filename, fileend);
			strcat(sample_files_test[i][j], sample_test_filename);
		}
	}
}

// This function sets all the array elements to 0
void clean_arrays(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int observation_sequence[TRAINING_SEQUENCES+1][T+1], long double alpha[T+1][N+1], long double beta[T+1][N+1],
					long double delta[N+1][T+1], long double psi[N+1][T+1], int Q_star[T+1], long double *p_star){
	// Cleaning A matrix
	for(int i=0; i<N+1; i++){
		for(int j=0; j<N+1; j++){
			A[i][j] = 0;
		}
	}

	// Cleaning B matrix
	for(int i=0; i<N+1; i++){
		for(int j=0; j<M+1; j++){
			B[i][j] = 0;
		}
	}

	// Cleaning Pi vector
	for(int i=0; i<N+1; i++){
		Pi[i] = 0;
	}

	// Cleaning observation sequence
	for(int i=0; i<TRAINING_SEQUENCES+1; i++){
		for(int j=0; j<T+1; j++){
			observation_sequence[i][j] = 0;
		}
	}

	// Cleaning alpha
	for(int i=0; i<T+1; i++){
		for(int j=0; j<N+1; j++){
			alpha[i][j] = 0;
		}
	}

	// Cleaning beta
	for(int i=0; i<T+1; i++){
		for(int j=0; j<N+1; j++){
			beta[i][j] = 0;
		}
	}

	// Cleaning delta
	for(int i=0; i<N+1; i++){
		for(int j=0; j<T+1; j++){
			delta[i][j] = 0;
		}
	}

	// Cleaning psi
	for(int i=0; i<N+1; i++){
		for(int j=0; j<T+1; j++){
			psi[i][j] = 0;
		}
	}

	// Cleaning p_star
	*p_star = 0;

	// Cleaning q_star
	for(int i=0; i<T+1; i++){
		Q_star[i] = 0;
	}

}

// This function reads the matrix A from file and write it to the 2D array
void read_A(char *filename, long double A[N+1][N+1]){
	FILE *fptr;
	char line[1024];
	char *temp, *token;
	int counter = 1;

	// opening file
	if((fptr = fopen(filename, "r")) == NULL){
		printf("ERROR: Can not open file %s.", filename);
		return;
	}

	// Read file line by line
	while(fgets(line, 1024, fptr)){
		token = strtok(line, "\t");
		for(int i=1; i<N+1; i++){
			// store the number 
			A[counter][i] = strtod(token, &temp);
			// get the next token
			token = strtok(NULL, "\t");
		}
		counter++;
	}
	fclose(fptr);
}

// This function prints the array A on the console. 
void print_A(long double A[N+1][N+1]){
	printf("\nA matrix:\n");
	for(int i = 1; i < N+1; i++){
		for(int j = 1; j < N+1; j++)
			printf("%g ", A[i][j]);
		printf("\n");
	}
	printf("\n");
}

// This function reads the matrix B from the file and stores it to array B
void read_B(char *filename, long double B[N+1][M+1]){
	FILE *fptr;
	char line[1024];
	char *temp, *token;
	int counter = 1;

	// opening file
	if((fptr = fopen(filename, "r")) == NULL && counter <= N){
		printf("ERROR: Can not open file %s.", filename);
		return;
	}

	// Read file line by line
	while(fgets(line, 1024, fptr)){
		token = strtok(line, "\t");
		for(int i=1; i<M+1; i++){
			// store the number 
			B[counter][i] = strtod(token, &temp);
			// get the next token
			token = strtok(NULL, "\t");
		}
		counter++;
	}
	fclose(fptr);
}

// This function prints the matrix B on the console
void print_B(long double B[N+1][M+1]){
	printf("\nB matrix:\n");
	for(int i = 1; i < N+1; i++){
		for(int j = 1; j < M+1; j++)
			printf("%g ", B[i][j]);
		printf("\n");
	}
	printf("\n");
}

// This function reads the vector PI from the file and stores it in array
void read_Pi(char *filename, long double Pi[N+1]){
	FILE *fptr;
	char line[1024];
	char *temp, *token;

	// opening file
	if((fptr = fopen(filename, "r")) == NULL){
		printf("ERROR: Can not open file %s.", filename);
		return;
	}

	// Read file
	fgets(line, 1024, fptr);
	token = strtok(line, "\t");
	for(int i=1; i<N+1; i++){
		// store the number 
		Pi[i] = strtod(token, &temp);
		// get the next token
		token = strtok(NULL, "\t");
	}
	fclose(fptr);
}

// This function prints the pi vector on the console
void print_Pi(long double Pi[N+1]){
	printf("\nPi vector:\n");
	for(int i=1; i<N+1; i++){
		printf("%g ", Pi[i]);
		printf("\n");
	}
	printf("\n");
}

// This function reads the observation sequence into matrix
void read_Observation_sequence(char *filename, long int Observation_sequence[TRAINING_SEQUENCES+1][T+1]){
	FILE *fptr;
	char line[1024];
	char *temp;
	int counter = 1;

	// opening file
	if((fptr = fopen(filename, "r")) == NULL){
		printf("ERROR: Can not open file %s.", filename);
		return;
	}

	char *token;
	int l=1;
	while(fgets(line, 1024, fptr)){
		// printf("%s\n", line);
		token = strtok(line, " ");
		for(int i=1; i<T+1; i++){
			// store the number 
			Observation_sequence[l][i] = strtol(token, &temp, 10);
			// get the next token
			token = strtok(NULL, " ");
		}
		l++;
	}
	fclose(fptr);
}

// This function prints the observation sequence
void print_Observation_sequence(long int Observation_sequence[TRAINING_SEQUENCES+1][T+1]){
	printf("Observation  Matrix-----------------------\n");
	for(int a = 1; a<TRAINING_SEQUENCES+1; a++){
		for(int b = 1;b<=T;b++)
			printf("%ld ", Observation_sequence[a][b]);
		printf("\n");
	}
}

// This function prints one observation sequence
void print_Observation_sequence(long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], int seq){
	printf("\nObservation sequence for sequence number %d:\n", seq);
	for(int b = 1; b<T+1; b++)
			printf("%ld ", Observation_sequence[seq][b]);
}

// THis function finds the average lambda model
void average_lambda(long double collect_A[TRAINING_SEQUENCES+1][N+1][N+1], long double collect_B[TRAINING_SEQUENCES+1][N+1][M+1], long double A[N+1][N+1], long double B[N+1][M+1]){
	for(int i=0; i<N+1; i++){
		for(int j=0; j<N+1; j++){
			A[i][j] = 0;
		}
	}
	for(int i=0; i<N+1; i++){
		for(int j=0; j<M+1; j++){
			B[i][j] = 0;
		}
	}
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			for(int k=1; k < TRAINING_SEQUENCES+1; k++){
				A[i][j] += collect_A[k][i][j];
			}
			A[i][j] /= (TRAINING_SEQUENCES * 1.0);
		}
	}

	for(int i=1; i<N+1; i++){
		for(int j=1; j<M+1; j++){
			for(int k=1; k < TRAINING_SEQUENCES+1; k++){
				B[i][j] += collect_B[k][i][j];
			}
			B[i][j] /= (TRAINING_SEQUENCES * 1.0);
		}
	}
}

// This function prints the lambda to file
void print_lambda_to_file(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], char *Afilename, char *Bfilename, char *pifilename){
	FILE *output_A = fopen(Afilename, "w");
	if(!output_A){
		printf("Cannot open file!\n");
		exit(0);
	}
 
	FILE *output_B = fopen(Bfilename, "w");
	if(!output_B){
		printf("Cannot open file!\n");
		exit(0);
	}
 
	FILE *output_pi = fopen(pifilename, "w");
	if(!output_pi){
		printf("Cannot open file!\n");
		exit(0);
	}
 
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; ++j){
			fprintf(output_A, "%g ", A[i][j]);
		}
 
		for(int j=1; j<M+1; ++j){
			fprintf(output_B, "%g ", B[i][j]);
		}
 
		fprintf(output_pi, "%g ", Pi[i]);
		fprintf(output_A, "\n");
		fprintf(output_B, "\n");
	}
 
	fclose(output_A);
	fclose(output_B);
	fclose(output_pi);
}

// This function finds the average lambda
void collect_lambda(int seq, long double collect_A[TRAINING_SEQUENCES+1][N+1][N+1], long double collect_B[TRAINING_SEQUENCES+1][N+1][M+1], long double A[N+1][N+1], long double B[N+1][M+1]){
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			collect_A[seq][i][j] = A[i][j];
		}
	}

	for(int i=1; i<N+1; i++){
		for(int j=1; j<M+1; j++){
			collect_B[seq][i][j] = B[i][j];
		}
	}
}

// This function replaces the A with A_BAR and B with B_BAR
void replace_with_new_A_and_B(long double A[N+1][N+1], long double B[N+1][M+1], long double A_BAR[N+1][N+1], long double B_BAR[N+1][M+1], long double Pi[N+1], long double Pi_BAR[N+1]){
	// change the values of A and B
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			A[i][j] = A_BAR[i][j];
		}
	}

	// change the values of B
	for(int i=1; i<N+1; i++){
		for(int j=1; j<M+1; j++){
			B[i][j] = B_BAR[i][j];
		}
	}

	// change the values of Pi
	for(int i=1; i<N+1; i++){
		Pi_BAR[i] = Pi[i];
	}
}

// making the matrices stochastic
void makestochastic(long double A[N+1][N+1], long double B[N+1][M+1]){
	for(int i=1; i<N+1; i++){
		long double sum_row = 0, max_row = -1e-30;
		// for each row
		int max_pos = -1;
		for(int j=1; j<=N; ++j){
			sum_row += A[i][j];
			if(max_row < A[i][j]){ max_row = A[i][j]; max_pos = j; }
		}
		A[i][max_pos] -= sum_row - 1;
	}

	for(int i=1; i<N+1; i++){
		long double row_sum = 0, cnt = 0;
		int row_max_index = 1;
		// for each row
		for(int j=1; j<M+1; j++){
			cnt += !B[i][j];
			B[i][j] = !B[i][j] ? 1e-30 : B[i][j];
			// find the maximum 
			row_sum += B[i][j];
			if(B[i][row_max_index] > B[i][j]){
				row_max_index = j;
			}
		}
		B[i][row_max_index] -= ((row_sum - (cnt * 1e-30)) - 1);
	}
	// check_for_stochastic_matrix(A, B);
	
}

// This function checks whether the passed matrix is stochastic or not
void check_for_stochastic_matrix(long double A[N+1][N+1], long double B[N+1][M+1]){
	// check row sum for 1
	for(int i=1; i<N+1; i++){
		long double sum = 0;
		for(int j=1; j<N+1; j++){
			sum += A[i][j];
		}
		if(sum != 1){
			printf("\nSum = %lf(A is invalid)", sum);
		}
		else{
			printf("\nSum = %lf(A is valid here)", sum);
		}
	}

	for(int i=1; i<N+1; i++){
		long double sum = 0;
		for(int j=1; j<M+1; j++){
			sum += B[i][j];
		}
		if(sum != 1){
			printf("\nSum = %lf(B is invalid)", sum);
		}
		else{
			printf("\nSum = %lf(B is valid here)", sum);
		}
	}
}

void initialize_bakis(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1]){
	// Initializing pi
	Pi[1] = 1;
	for(int i=2; i<N+1; i++){
		Pi[i] = 0;
	}

	// Initializing A
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			A[i][j] = 0;
			if(i == j && j!=N){
				A[i][j] = 0.8;
			}
			if(i == j-1 && i!=N){
				A[i][j] = 0.2;
			}
		}
	}
	A[N][N] = 1;

	// Initializing B
	long double val = 1/(long double)M;
	for(int i=1; i<N+1; i++){
		for(int j=1; j<M+1; j++){
			B[i][j] = val;
		}
	}
}

// This function will print the lambda to file
void print_lambda(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1]){
	printf("\nConverged Lambda: \nA matrix:\n");
	for(int i=1; i<N+1; i++){
		for(int j=1; j<N+1; j++){
			printf("%Le ", A[i][j]);
		}
		printf("\n");
	}

	printf("\nB matrix:\n");
	for(int i=1; i<N+1; i++){
		for(int j=1; j<M+1; j++){
			printf("%Le ", B[i][j]);
		}
		printf("\n");
	}

	printf("\nPi matrix:\n");
	for(int i=1; i<N+1; i++){
		printf("%Le ", Pi[i]);
	}
}

// This function reads the lambda from the file to variables
void load_lambda(long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], char* A_file_paths_train, char* B_file_paths_train, char* Pi_file_paths_train){
	FILE* input_A = fopen(A_file_paths_train, "r");
	if(!input_A){
		printf("Cannot read file %s!\n", A_file_paths_train);
		exit(0);
	}
 
	FILE* input_B = fopen(B_file_paths_train, "r");
	if(!input_B){
		printf("Cannot read file %s!\n", B_file_paths_train);
		exit(0);
	}
 
	FILE *input_pi = fopen(Pi_file_paths_train, "r");
	if(!input_pi){
		printf("Cannot read file %s!\n", Pi_file_paths_train);
		exit(0);
	}
 
	for(int i=1; i<=N; ++i){
		for(int j=1; j<=N; ++j){
			fscanf(input_A, "%lf", &A[i][j]);
		}
		for(int j=1; j<=M; ++j){
			fscanf(input_B, "%lf", &B[i][j]);
		}
		fscanf(input_pi, "%d", &Pi[i]);
	}
 
	//print_lambda();
	fclose(input_A);
	fclose(input_B);
	fclose(input_pi);
}

/*
// This function prints the lambda to file
void print_lambda_to_file(){
	FILE *output_A = fopen("output/A.txt", "w");
	if(!output_A){

	}
}
*/

void viterbi_algorithm(bool is_print_result, int seq, long double A[N+1][N+1], long double B[N+1][M+1], long double Pi[N+1], long int Observation_sequence[TRAINING_SEQUENCES+1][T+1], long double delta[N+1][T+1], long double psi[N+1][T+1], int Q_star[T+1], long double *p_star){
	// Initialization
	for(int i=1; i<N+1; i++){
		delta[i][1] = Pi[i] * B[i][Observation_sequence[seq][1]];
		psi[i][1] = 0;
	}

	long double max=0;
	int index=0;
	// Iteration
	for(int t=2; t<T+1; t++){
		for(int j=1; j<N+1; j++){
			// set the initial values
			max = 0;
			for(int i=1; i<N+1; i++){
				if((delta[i][t-1] * A[i][j]) > max){
					// change the index for max value
					max = delta[i][t-1] * A[i][j];
					index = i;
				}
			}
			// set the results
			delta[j][t] = max * B[j][Observation_sequence[seq][t]];
			psi[j][t] = index;

		}
	}

	// Terminating
	long double p_s = 0;
	for(int i=1; i<N+1; i++){
		// compare with max to get max
		if(delta[i][T] > p_s){
			p_s = delta[i][T];
			Q_star[T] = i;
		}
	}
	// set p*
	*p_star = p_s;

	// finding state sequence
	for(int t=T-1; t>0; t--){
		Q_star[t] = psi[Q_star[t+1]][t+1];
	}

	// checking print result condition
	if(is_print_result){
		printf("P_star = %g\n", *p_star);
		printf("Q_star:\n");
		for(int i=1; i<T+1; i++){
			printf("%d ", Q_star[i]);
		}
	}
}

// this function returns the random prediction
int get_prediction(){
	long double Pi2[] = {0, 1, 0, 0, 0, 0};
	clean_arrays(A, B, Pi, Observation_sequence, alpha, beta, delta, psi, Q_star, &P_star); 
	generate_observation_sequence(codebook, "samples.txt", 1, Observation_sequence, weight);
	int predicted_digit = 1;
	long double max_prob = DBL_MIN, prob=0;
	// print_Observation_sequence(Observation_sequence);
	for(int check_word=0; check_word<word_count; check_word++){
		load_lambda(A, B, Pi2, A_file_paths_train[check_word], B_file_paths_train[check_word], Pi_file_paths_train[check_word]);
		// print lambda
		// print_lambda(A, B, Pi);
		prob = generate_alpha(false, false, 1, A, B, Pi2, Observation_sequence, alpha);
		// printf("\nprob: %Le", prob);
		if(max_prob < prob){
			max_prob = prob;
			predicted_digit = check_word;
		}
	}
	return predicted_digit;
}

int get_prediction_random(){
	// generate random number
	return 1 + (rand())%9;
}

char initialize_hmm(){
	P_star = 0;
	// codebook[M+1][p+1] = {{0}}
	for(int i=0; i<M+1; i++){
		for(int j=0; j<p+1; j++){
			codebook[i][j] = 0;
		}
	}
	// defining weights
	// weight[p] = {1.0, 3.0, 7.0, 13.0, 19.0, 22.0, 25.0, 33.0, 42.0, 50.0, 56.0, 61.0}
	weight[0] = 1.0;
	weight[1] = 3.0;
	weight[2] = 7.0;
	weight[3] = 13.0;
	weight[4] = 19.0;
	weight[5] = 22.0;
	weight[6] = 25.0;
	weight[7] = 33.0;
	weight[8] = 42.0;
	weight[9] = 50.0;
	weight[10] = 56.0;
	weight[11] = 61.0;
	generate_paths();
	// This part generates the codebook
	strcpy(codebook_file_path, "Allfiles/codebook.txt");
	read_codebook(false, codebook_file_path, codebook);
	return A_file_paths_train[1][1];
}